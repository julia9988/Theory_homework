	1.	Цели тестирования
Можно определить такие основные цели тестирования программного обеспечения:
– Предоставление информации о качестве ПО конечному заказчику;
– Повышение качества ПО;
– Предотвращение появления дефектов.
Цели тестирования могут отличаться, в зависимости от этапа разработки ПО, на котором оно проводится. К примеру, на этапе кодирования целью тестирования будет вызов как можно большего количества сбоев в работе программы, что позволит локализовать и исправить дефекты. В то же время, при приемочном тестировании необходимо  показать, что система работает правильно. В период сопровождения, тестирование в основном необходимо для того, чтобы  убедится в отсутствии новых багов, появившихся во время внесения изменений.
Главная же задача тестирования – поиск дефектов и чтобы продукт нравился пользователям.

2. Цели, зависимости от того. когда вы начали тестирование
фича конечный продукт регресс и тд
подписать их цели. мы тестируем чтобы что

Для любого проекта цели тестирования могут включать:
● Оценку рабочих продуктов, таких как требования, пользовательские истории, проектирование и код
● Проверку, все ли указанные требования выполнены
● Проверку, завершен ли объект тестирования и работает, как ожидают пользователи и
заинтересованные лица
● Создание уверенности в уровне качества объекта тестирования
● Предотвращение дефектов
● Обнаружение отказов и дефектов
● Предоставление заинтересованным лицам достаточной информации, позволяющей им принять обоснованные решения, особенно в отношении уровня качества объекта тестирования
● Снижение уровня риска ненадлежащего качества программного обеспечения (например, пропущенные сбои в работе)

Соблюдение договорных, правовых или нормативных требований, или стандартов и/или проверка соответствия объекта тестирования таким требованиям и стандартам
Цели тестирования могут варьироваться в зависимости от контекста тестируемого компонента или системы, уровня тестирования и модели жизненного цикла разработки программного обеспечения. Эти различия могут включать:
● При компонентном тестировании одна из целей может заключаться в том, чтобы найти как можно больше сбоев, чтобы выявить и устранить основные дефекты на ранних стадиях. Другая цель может быть увеличением покрытия кода тестами компонентов.
● При приемочном тестировании одна из целей может заключаться в том, чтобы подтвердить, что система работает, как ожидалось, и удовлетворяет требованиям. Другая цель этого тестирования может быть предоставлением информации заинтересованным лицам о риске выпуска в установленный срок.

3.Принципы тестирования

Принцип No1 - тестирование показывает наличие дефектов. Тестирование может показать, что в продукте существуют дефекты, но не сигнализирует о том, что дефектов не существует вообще. Т.е. в процессе тестирования мы снижаем вероятность того, что в продукте остались дефекты. Но, даже если мы их вообще не обнаружили, то мы не можем говорить о том, что их нет. Из моей практики, баги в продукте есть всегда.
Принцип No2 - исчерпывающее тестирование невозможно. Протестировать абсолютно всё в продукте невозможно. И даже если вам кажется обратное, то вы потратите огромное количество времени на это, а как известно - время деньги. А как тогда быть уверенным в том, что продукт работает корректно? Всегда есть риски и приоритеты. Для того, чтобы минимизировать риски, есть специальные техники тест-дизайна, которые помогают тестерам проектировать свои тесты так, чтобы с минимальными усилиями покрыть как можно больше тестовых случаев и функциональностей.
Принцип No3 - это раннее тестирование. Т.е. тестовые активности должны начинаться как можно раньше и всегда преследовать определенные цели. В данном случае экономия средств заказчика.
Принцип No4 - скопление дефектов. Он гласит так: в небольшом количестве модулей сокрыто большое количество дефектов. И если мы вспомним с вами правило Парето, то оно применимо и к данному принципу: 80% дефектов находится в 20% функций. Т.е. мы должны понимать, что наибольшее количество дефектов сконцентрировано не во всём приложение, а в какой-то определенной из его функциональностей, поэтому тестеры должны распределять свои усилия пропорционально. Например, если он понимает, что в модуле логина пользователя в систему всегда происходят какие-то физические дефекты, то он должен больше время сконцентрировать на нахождение и устранение этих дефектов именно в этой функциональности.
Принцип No5 - парадокс пестицида. Прогоняя одни и те же тесты вновь и вновь, вы столкнетесь с тем, что они находят всё меньше новых ошибок, поскольку системы эволюционируют. Многие из ранее найденных дефектов исправляют и старые тесты больше не срабатывают. Чтобы преодолеть этот парадокс, необходимо периодически вносить изменения в используемые наборы тестов, корректировать их так, чтобы они отвечали новому состоянию системы и позволяли находить как можно большее количество дефектов. Для этого также нужно постоянно изучать новые методы тестирования и внедрять их свою работу. Для преодоления данного препятствия можно давать прогонять тесты другим участникам команды, либо же производить ротацию кадров, чтобы разные тестировщики в разное время тестировали одну и ту же функциональность. Кстати, вопрос по минимизации данного риска часто задают на собеседовании, так что обязательно запомните ответ на него. Почему же этот принцип называется парадокс пестицида? Всё очень просто. Проведите аналогию с применением какого-то химиката против насекомых, либо же каких-то сорняков. Если их постоянно травить одним и тем же инсектицидом или пестицидом, то у них возникает привыкание, они адаптируются и меньшее количество живности вымирает, либо уничтожается под действием того или иного токсиканта. Также работает принцип пестицида для тестирования.
 
Принцип No6 - тестирование зависит от контекста. Выбор методологии, техники или типа тестирования будет напрямую зависеть от природы самой программы. Например, программное обеспечение для медицины требует более тщательной проверки, чем компьютерная игра. Или же сайт с большей посещаемостью должен пройти через серьёзное тестирование производительности, чтобы показать возможность работы в условиях высокой нагрузки. Поэтому тестировщик всегда должен ответственно подходить к выбору той среды, в которой он будет тестировать, к выбору той документации, которую будет тестировать. Например, если продукт сложный, то лучше выбрать тест-кейсы, а не чек-листы.
Принцип No7 - это заблуждение об отсутствии ошибок. Каждому тестировщику не стоит полагать, что если тестирование не обнаружило дефект, то программа готова к релизу. Нахождение и исправление дефектов будут не важны, если система окажется неудобна в использовании и не будет удовлетворять нуждам пользователя.





Классификация тестирования по степени важности тестируемых функций. 
Smoke testing (дымное, дымовое). Проводится на начальном этапе, например после нового билда. Это некая промежуточная версия нашего продукта. 
Цель:  проверка готовности разработанного продукта к проведению расширенного тестирования и определение общего состояния качества продукта. Обычно это короткий цикл тестов, либо же вообще один тест, который подтверждает, либо отрицает факт того, что приложение стартует, либо выполняет свои основные функции. На примере уже полюбившегося нам интернет магазина, smoke тестирование представляет собой один тест-кейс, когда мы логинимся в систему, ищем необходимый нам товар, добавляем его в корзину производим оплату, подтверждаем и получаем наш заказ. Т.е. все вот эти вот шаги можно смело вносить в один тестовый случай. Если он будет проходить, т.е. ожидаемый и фактический результат будут одинаковыми - получаем наш товар, то smoke тестирование считается успешным. Для smoke теста есть только два варианта развития событий. Мы можем сказать либо да, либо нет. В случае, если мы говорим нет, то дальнейшее тестирование не проводится, мы направляем баг на разработчика и останавливаем процесс тестирования полностью. Стоит отметить, что smoke тесты должны быть быстрыми и легковесными для того, чтобы их можно было запускать очень часто. Забавный факт, как вообще появилось такое название, как smoke тестирование? Одна версия про печников, т.е. когда печники заканчивали строительство той или иной печи, то они зажигали в ней огонь и, если из некоторых отверстий, которые по сути должны были быть цельными, выходил дым, то тогда люди понимали, что был нарушен какой-то процесс строительства, либо конструирование данной печи. А вторая версия связана со схемотехниками. Т.е. когда запускали какой-либо станок, либо суперкомпьютер, если платы начинали дымится после какой-то высокой нагрузки, то люди понимали, что был нарушен какой-то технологический процесс и, опять же, нужно что-то исправлять. Поэтому за этим типом тестирования и закрепилось такое название, как smoke, либо дымное тестирование. 
Тест критического пути (critical path test). Основной тип тестовых испытаний, во время которого значимые элементы и функции приложения проверяются на предмет правильности работы при стандартном использовании. Т.е., это типичный пользователь, в типичной повседневной жизни, выполняет какие-то свои типичные задачи. И именно эти типичные задачи мы проверяем чаще всего. На практике на данном уровне тестирования проверяется основная масса требований к продукту. Например, выбор шрифта, возможность набора текста, вставка картинок и так далее. Может быть как позитивным, так и негативным. 
Расширенный тест (extended test). Под данным тестированием подразумевается проверка нестандартного использования программного продукта. Например, если мы будем вводить специальные символы в поле логина, либо же нелогично кликать по кнопкам, работать на многие вкладках одновременно, т.е. максимально загружать нашу систему, либо выполнять какие-то выдуманные негативные тесты. Это то, что я хотел рассказать о тестах по степени важности. Классификация тестирования по цели тестирования. 
New feature test (тестирование новой функциональности). Это проверка качества новой функциональности, поставленной на тестирование. Обычно new feature test тестируется полным тестом, т.е. проходит все этапы, начиная со smoke, Затем идёт тест физического пути и заканчивается расширенным тестом. Тестировщики практически каждый день сталкиваются с new feature test, т.е., по сути, новая функциональность приходит к тестерам во время какого-то спринта. Вы должны представлять, что спринт - это некоторый промежуток времени в котором команда доставляет некоторую новую функциональность до нашего заказчика и представляет её. И вот именно в этом спринте часто приходят какие-то новые фичи, новые функциональности, которые в дальнейшем будут тестироваться в рамках new feature тест. 
Регрессионное тестирование (Regression testing). Стоит отметить самую важную часть тестирования, которая занимает у тестировщиков больше всего времени - это регрессионное тестирование. Что же такое regression testing? Это тестирование ранее проверенной функциональности, с целью удостовериться, что изменения в коде, например добавление новой функциональности, либо же исправления какого-либо дефекта, не повлияли на работу старой функциональности. Регрессионное тестирование может быть проведено как на уровне smoke, так и на уровне critical path test, а также на уровне extended test. Я хочу более подробно остановиться на данном виде тестирования, потому что часто на собеседованиях могут спросить некоторые подводные камни, связанные именно с этим видом тестирования, и в принципе для того, чтобы у вас сложилось некоторое понимание, почему этот тип тестирования так важен в нашей работе. Данный вид тестирования обязательно проводится в каждом новом билде. Как вы помните, build - это промежуточная версия нашего продукта. Данный вид тестирования может включать в себя проверку исправленных багов, их степень влияния на весь продукт, либо же на какую-то определенную функциональность. Вам нужно понимать, что регрессионное тестирование обычно не покрывает всё приложение, а только те участки, которые тем или иным способом соприкасаются с изменением их кода. Например, если мы говорим о странице авторизации пользователя в систему, то если вдруг проводили какое-то изменение, связанное со сбросом пароля (обычно эти две функциональности - логин в систему и сброс пароля, либо его восстановление) взаимосвязаны между собой, поэтому обязательно, в случае вот таких вот изменений нужно проверять взаимосвязанные функциональности. Также регрессионное тестирование рекомендуется проводить несколько раз, а, так как функциональностей в приложении может быть очень много, то регрессионное тестирование любят очень часто автоматизировать, для того, чтобы сэкономить время тестировщиков и вообще в целом время для тестирования. Стоит отметить, что финальное регрессионное тестирование в этом большом цикле, состоящем из трех-пяти регрессий, обычно определяется после выставления некоторых приоритетов, а приоритеты, в свою очередь, определяются наибольшим количеством найденных ошибок в системе. Часто на собеседовании опять же могут спросить, как осуществить выбор тестов для регрессии. Есть очень простой алгоритм, который вам расскажу. Во-первых, в регрессию всегда нужно включать тесты, которые покрывают тестирование безопасности, либо каких-то критичных важных функций для бизнеса. Обязательно нужно включать в регрессию те области, которые чаще всего меняются в ходе разработки. Также, из одного из принципов тестирования вытекает еще один принцип выборки теста для регрессии - обязательно нужно включать тесты функции с высокой вероятностью ошибки. 
Re-test. Это проверка результата работы над дефектом, проверка правильности исправления дефекта. Т.е., когда разработчик направляет на вас уже пофикшеный баг, то вы проводите ретест. Т.е. убеждаетесь в том, что девелопер на самом деле пофиксил данный дефект и функциональность действительно отрабатывается так, как было задумано в требованиях

2 типа тестирования по степени автоматизации: ручное тестирование, которое мы изучаем в рамках данного курса, и автоматизированное тестирование. При ручном тестировании тестировщики вручную выполняют тесты, не используя никаких средств автоматизации. Что касается автоматизированного тестирования, то оно предполагает использование специального программного обеспечения, помимо того, что мы тестируем, для контроля выполнения тестов и сравнения ожидаемого и фактического результатов работы программы. Этот тип тестирования помогает автоматизировать часто повторяющиеся, но необходимые для максимизации тестового покрытия задач. Основными объектами для автоматизации являются: регрессионное тестирование, которое занимает огромное количество времени и представляет собой рутину и повторение тех тестов, которые мы уже проводили, а также smoke тестирование, которое проводится самым первым. Бытует такое мнение, что автоматизированное тестирование заменит ручное. На самом деле это не так, так как не все функциональности можно проверить только написанными автоматизированными тестами, либо скриптами, поэтому ручники будут актуальны всегда, и работа для них тоже будет находиться всегда. Сейчас популярны гибридные тестировщики. Иногда ручные тестировщики пишут какие-то тестовые сценарии, отдают их автоматизаторам, которые в дальнейшем пишут программный код, скрипт и выполняет уже данные тесты, т.е. получается некий симбиоз. 
Классификация тестирования по знанию кода. Тестирование черного ящика (black box). Мы не знаем, как устроена тестируемая система. Также, вы можете найти такие названия этого тестирования, как тестирование, основанное на спецификации или тестирование поведения. Что это значит? Эта техника тестирования основана на работе исключительно с внешними интерфейсами тестируемой системы, т.е. мы вообще не знаем программный код. Примером может быть когда тестировщик проводит тестирование веб-сайта, не зная особенности его реализации, используя только предусмотренные разработчиком поля ввода и кнопки. Источником ожидаемого результата будут спецификации т.е. мы тестируем только GUI (графический) интерфейс. 
White box testing (тестирование белого ящика). В отличие от тестирования черного ящика, white box testing (тестирование белого ящика) представляет собой следующее: нам известны все детали реализации тестируемой программы, т.е. это такой метод тестирования, который предполагает, что внутренняя структура, устройство и реализация, известны тестировщику. Примером может быть то, когда тестировщик, который как правило, является либо автоматизатором, либо возможным программистом, изучает реализацию кода поля ввода на веб-странице, определяет все предусмотренные, как правильные, так и неправильные пользовательские вводы и сравнивает фактический результат выполнения программы с ожидаемым. При этом ожидаемый результат определяется именно тем, как должен работать код программы. Grey box test (серый ящик). Здесь нам уже известны только некоторые особенности реализации тестируемой системы. Это такой метод тестирования ПО, который предполагает комбинацию двух предыдущих, т.е. внутреннее устройство программы нам известно лишь частично. Например, мы знаем внутреннюю структуру и алгоритм работы программного обеспечения для того, чтобы написать максимально эффективные тест-кейсы, но само тестирование проводится с помощью техники черного ящика, т.е. с позиции нашего конечного пользователя. Функциональное тестирование. Вот так мы и подошли к самой интересной части нашего сегодняшнего занятия, а именно функциональному и не функциональному тестированию. Что же это такое функциональное тестирование? Это один из видов тестирования, направленного на проверку соответствия функциональных требований ПО его реальным характеристикам. Ключевое здесь - функциональные требования, т.е. мы проверяем, что наша система делает. Основная задача функционального тестирования - подтверждение того, что наш разрабатываемый продукт обладает всем функционалом, который требует заказчик. Это тестирование проводится на всех уровнях и, как я уже сказал, проверяет то, что система делает. 

Нефункциональное тестирование.
 Целью нефункционального тестирования является проверка соответствия свойств приложения с его нефункциональными требованиями, т.е. при данном виде тестирования мы проверяем, как наша система работает. По сути, это тестирование свойств, которые не относятся к функциональности системы. Данные свойства определяются их функциональными требованиями. Тестирование на отказ и восстановление. К таким свойствам можно отнести, например, надежность, т.е. реакцию системы на непредвиденные ситуации и в данном случае к данному свойству будет применимо такое тестирование. Т.е. это исследование программных систем на предмет восстановления после ошибок и сбоев. 

Тестирование производительности. Второе свойство - это производительность, т.е. работоспособность системы под разными нагрузками. На самом деле тестирование производительности - это огромный пласт навыков и инструментариев, поэтому есть отдельные тестировщики, которые занимаются именно этим видом тестирования. Т.е., если вы им заинтересуетесь, конечно же, можно переходить на специализированные курсы, учиться читать специальную литературу и использовать уже техники тестирования производительности в своей практике. Что же это такое, тестирование производительности? Это комплекс типов тестирования, целью которого является определение работоспособности, стабильности потребления ресурсов и других атрибутов. Качество приложения в условиях различных сценариев использования и нагрузок, и, в свою очередь, тестирование производительности также можно разделить на несколько видов тестирования: 
1. Нагрузочное тестирование. Мы проверяем производительность при нормальных условиях, т.е. если у нас заявлено, что на сайте должны одновременно присутствовать тысячи пользователей, мы создаем такие специальные условия, например, в программе jmeter, когда нагружаем нашу систему на количество пользователей, которое будет чуть меньше этой тысячи и проверяем, что все действительно ок. 
2. Стресс-тестирование. Мы проверяем работоспособность нашей системы при экстремальных нагрузках, когда, например, на сайте присутствуют именно тысячи пользователей, возможно даже больше. 
3. Тестирование стабильности. Представляет собой проверку нашего приложения при длительной работе. 
4. Объемное тестирование - тестируем нашу систему при увеличенных объемах обрабатываемых данных, т.е., например, когда те же самые тысячи пользователей отправляют одновременно энное количество мегабайт информации. 
Тестирование удобства использования, т.е. исследование удобства работы с приложением с точки зрения пользователя. Это можно протестировать с помощью не заберёте юзабилити testing, т.е. тестирование удобства использования. 
Проверка юзабилити приложения заключается в том, что мы оцениваем соответствие дизайна приложения к его функциональности, которое задается заказчиком. Также здесь мы можем исследовать используемые графические элементы, цветовые оформления с точки зрения восприятия нашим пользователем, удобство навигации и ссылки, которые есть у нас на данном сайте, анализ текстового наполнения сайта. Также существует такая характеристика как обучаемость, например, если наш пользователь первый раз зашел на тот или иной ресурс, насколько быстро он сможет сообразить, как им пользоваться. Например, на своем каком-то предыдущем эксперименте, когда он пользовался подобным приложением от нашего конкурента, поэтому, если мы не учтем все эти аспекты, пользователь, скорее всего, перейдет к нашему конкуренту, если будет неудобно использовать наш продукт. Сейчас это тестирование очень распространено. Оно имеет огромное значение и, опять же, существуют целые группы тестировщиков, специалистов, которые заточены именно на тестирование удобства использования. Также есть специализированные курсы, которые позволяют обучиться данным техникам. 
Тестирование безопасности, т.е. защищенность пользовательских данных. Это тоже достаточно обширное направление в тестировании. Существуют специальные тестировщики, которые занимаются именно тестированием безопасности. Есть отдельные направления, например, здесь мы можем протестировать насколько просто неавторизованный пользователь получит доступ к системе, либо же насколько просто постороннему лицу получить доступ к данным. Т.е. мы тестируем то, как реализована защищенность нашего программного продукта. 
Ещё одно свойство - это портируемость, т.е. переносимость нашего приложения на различные платформы. Здесь мы можем использовать такие типы тестирования, как тестирование установки и конфигурационные тестирование.
 Тестирование установки. Здесь мы проверяем успешность установки приложения, его настройку обновления и удаления. Конфигурационное тестирование. Здесь мы исследуем работоспособность программной системы в условиях различных программных конфигураций. К данному виду тестирования можно отнести кроссплатформенное и кроссбраузерное тестирование. Я думаю здесь не стоит очень подробно объяснять, что это такое, думаю всем понятно.
 1. Кроссплатформенное - значит, что мы тестируем наш продукта на различных типах и версиях оперативных систем. Например, мобилки – android, либо ios. 2. Кроссбраузерное тестирование - мы используем наше приложение на различных браузерах. Chrome, Mozilla, Opera. Также стоит рассказать о тестировании локализации (l10n) и тестирование интернационализации (i18n). Очень часто вы можете найти такие сокращения, не пугайтесь, если вы их увидите, возможно где-то на собеседование будет какой-либо тест, либо вас спросят, как можно сократить эти названия, просто запомните. Это, по сути, сокращение от их английских названий. 

Тестирование локализации (l10n) - это процесс адаптации нашего программного продукта к языку и культуре клиента. Например, если мы выходим на какой-то другой рынок, например, англоязычный, то мы должны проверить, насколько наш продукт полностью переведён на этот язык, либо же, возможно, там используются какие-то финансовые обозначения, например, фунта. Это мы тоже должны проверить. Ещё можно к этому отнести контроль формата даты и времени, правовые какие-то особенности того государства, на которое мы выходим, контроль раскладки клавиатуры пользователя, контроль символики и цветов, и другие аспекты, которые могут быть связаны с той или иной локацией, на которой мы будем представлять наш продукт. 
Тестирование интернационализации (i18n). В отличие от локализации, это тестирование включает в себя: насколько наш продукт может в дальнейшем адаптироваться для той, либо иной локации. Например, при создании продукта мы должны учесть возможность кодировки unicode, т.е. такого стандарта кодирования, который поддерживается, практически, во всех языках мира, либо же мы должны предусмотреть в приложении возможность поддержки элементов, которые невозможно локализовать обычным образом. Например, это может быть вертикальный текст азиатских стран, либо же чтение справа налево в арабских странах, т.е. даже если мы на данный момент не используем наше приложение в азиатских странах, то всё равно нужно досмотреть в будущем, что данное приложение может выйти и на эти рынки, поэтому мы должны также протестировать интернационализацию. 
Тестирование GUI (графического интерфейса) пользователя. Т.е. это проверка соответствия приложения требованиям к графическому интерфейсу, насколько профессионально оно выглядит, выполнено ли оно в едином стиле, т.е. на том ли месте находятся те кнопки, которые у нас есть на том мокапе, т.е. шаблоне, который предоставил нам дизайнер. Т.е. всё это мы проверяем при тестировании GUI Классификация тестирования по исполнению сценария. Иногда на собеседованиях спрашивают, например: что такое ad-hoc тестирование? И не все могут ответить на этот вопрос. Давайте немножко разберемся, что это такое. Здесь можно выделить три вида тестирования. Это исследовательское тестирование, ad-hoc тестирование и сценарное тестирование. 
Ad-hoc тестирование - представляет собой тестирование без использования каких-либо спецификаций, планов и разработанных тест-кейсов. Это ваша чистая импровизация, т.е., например, вы в первый раз получили приложение и на каком-то своем эмпирическом, на традиционном уровне, понимаете, как с ним нужно работать. Исследовательское тестирование, в отличие от ad-hoc, более формальная версия тестирование. Она не требует написания тест-кейсов, но в то же время подразумевает, что каждый последующий тест выбирается на основании результатов предыдущего теста. Даже если вы знаете, как работает ваше приложение, т.е. вы его не в первый раз видите, то вы можете также следовать какому-то плану. Не обязательно его документировать. Т.е. вы знаете, что в таком-то модуле есть такой-то ожидаемый результат и вы это тестируете, но не оформляете это посредством тестовой документации. 
Сценарное тестирование, т.е. это наше классическое тестирование по предварительно написанным и уже задокументированным тестовым сценариям. 

Классификация тестирования по запуску кода. Если вы вспомните урок верификации и валидации, мы говорили с вами о том, что верификация - это статическая проверка, а валидация - это динамическая проверка. Это применимо и к данной классификации, т.е. есть статическое тестирование и динамическое тестирование. 

Статическое тестирование. Не предполагается, что программный код во время тестирования будет выполняться. Т.е. мы его не запускаем. Статическое тестирование начинается на ранних этапах жизненного цикла программного обеспечения и является соответствующей частью процесса верификации. Сюда можно включить тестирование любых форм документации, например, вычитку кода, инспекцию проектной документации, функциональных спецификаций и наших требований. 
Динамическое тестирование. Это такой тип тестирования, который предполагает запуск программного кода. Таким образом анализируется поведение программы во время ее работы. И есть еще такое интересное направление, как тестирование доступности (accessibility testing). Т.е. здесь мы проверяем соответствие по общепризнанным стандартам доступности. Оно должно быть доступно для использования людьми с ограниченными возможностями. Есть отдельный документ, который регламентирует то, как наше приложение должно быть доступно для таких людей. Опять же, это отдельное направление в тестировании, поэтому я не буду более подробно останавливаться на нем, но оно очень интересное. Стоит отметить, что многие заблуждаются в том, что люди с ограниченными возможностями должны иметь какие-то проблемы со здоровьем, которые мешают им пользоваться нашим программным обеспечением. На самом деле это не совсем так. К таким людям, например, можно отнести тех, кто, к примеру, едет в машине и сконцентрирован на движении, т.е. смотрит на дорогу, однако, в то же время, он пользуется каким-то гаджетом, т.е. он ограничен в своих возможностях, он не может видеть всё, что происходит на экране своего смартфона, но может, например, слышать. Либо, если у женщины есть ребенок, она его держит на одной руке и пользуется, опять же, нашим гаджетом, смартфоном. Она должна пользоваться только одной рукой, это ограничивает ее в движениях, и также мы должны предусмотреть такую возможность. Поэтому не всегда люди с ограниченными возможностями - это люди, у которых есть какие-то проблемы со здоровьем
